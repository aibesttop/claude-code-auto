# Bug #4: äº‹ä»¶å¾ªç¯å†²çª - ç ”ç©¶å·¥å…·æ— æ³•è¿è¡Œ

**å‘ç°æ—¶é—´**: 2025-01-22 16:27
**ä¸¥é‡æ€§**: ğŸ”´ Critical (ç ”ç©¶å·¥å…·å®Œå…¨æ— æ³•ä½¿ç”¨)
**çŠ¶æ€**: âœ… å·²ä¿®å¤

---

## é—®é¢˜æè¿°

### é”™è¯¯ä¿¡æ¯
```
ERROR | âŒ Sandbox caught error in deep_research: This event loop is already running
ERROR | âŒ Tool execution failed: This event loop is already running
RuntimeWarning: coroutine 'ResearcherAgent.deep_research' was never awaited
RuntimeWarning: coroutine 'ResearcherAgent.research' was never awaited
```

### å¤ç°åœºæ™¯
- **å·¥å…·**: `deep_research`, `quick_research`
- **è§¦å‘**: åœ¨Team Modeä¸­ä»»ä½•è§’è‰²è°ƒç”¨ç ”ç©¶å·¥å…·
- **é¢‘ç‡**: 100%å¤±è´¥

### å½±å“èŒƒå›´
- âŒ æ‰€æœ‰ç ”ç©¶åŠŸèƒ½æ— æ³•ä½¿ç”¨
- âŒ Market-Researcherè§’è‰²æ— æ³•å®Œæˆä»»åŠ¡
- âŒ ä¾èµ–ç ”ç©¶çš„æ‰€æœ‰ä¸‹æ¸¸è§’è‰²è¢«é˜»å¡

---

## æ ¹æœ¬åŸå› åˆ†æ

### é”™è¯¯çš„å®ç°

```python
# src/core/tools/research_tools.py (é”™è¯¯ç‰ˆæœ¬)
@tool
def quick_research(query: str) -> str:
    researcher = get_researcher()

    # âŒ é—®é¢˜ä»£ç 
    try:
        loop = asyncio.get_event_loop()  # è·å–å½“å‰å¾ªç¯
    except RuntimeError:
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

    result = loop.run_until_complete(researcher.research(query))  # ğŸ’¥ å¤±è´¥!
    return result
```

### æ‰§è¡Œæµç¨‹åˆ†æ

```
1. executor.execute_task() [async function]
   â””â”€ Event Loop: RUNNING âœ…

2. await run_claude_prompt(...) [async call]
   â””â”€ Event Loop: RUNNING âœ…

3. ReAct loop iteration
   â””â”€ Event Loop: RUNNING âœ…

4. registry.execute("quick_research", args) [sync call]
   â””â”€ Event Loop: RUNNING âœ…

5. quick_research() function
   â”œâ”€ loop = asyncio.get_event_loop()  # âœ… æˆåŠŸè·å–å½“å‰å¾ªç¯
   â”œâ”€ loop.is_running() = True  # âŒ é—®é¢˜: å¾ªç¯æ­£åœ¨è¿è¡Œ!
   â””â”€ loop.run_until_complete(coro)  # ğŸ’¥ RuntimeError: This event loop is already running
```

### ä¸ºä»€ä¹ˆä¼šå¤±è´¥

1. **åµŒå¥—äº‹ä»¶å¾ªç¯é—®é¢˜**:
   - `executor.execute_task()` æ˜¯asyncå‡½æ•°,è¿è¡Œåœ¨äº‹ä»¶å¾ªç¯ä¸­
   - è°ƒç”¨åŒæ­¥å·¥å…· `quick_research()`
   - å·¥å…·å°è¯•ç”¨ `run_until_complete()` è¿è¡Œasyncæ–¹æ³•
   - ä½†äº‹ä»¶å¾ªç¯å·²ç»åœ¨è¿è¡Œ,ä¸èƒ½å†æ¬¡è°ƒç”¨ `run_until_complete()`

2. **é”™è¯¯çš„å‡è®¾**:
   ```python
   # ä»£ç å‡è®¾: è¦ä¹ˆæœ‰å¾ªç¯è¦ä¹ˆæ²¡æœ‰
   try:
       loop = asyncio.get_event_loop()  # è·å–åˆ°äº†å¾ªç¯
   except RuntimeError:
       loop = asyncio.new_event_loop()  # ä¸ä¼šæ‰§è¡Œ

   # ä½†æ²¡æœ‰æ£€æŸ¥: å¾ªç¯æ˜¯å¦æ­£åœ¨è¿è¡Œ!
   loop.run_until_complete(coro)  # âŒ å¦‚æœå¾ªç¯åœ¨è¿è¡Œå°±ä¼šå¤±è´¥
   ```

3. **asyncioé™åˆ¶**:
   - `run_until_complete()` åªèƒ½åœ¨æ²¡æœ‰è¿è¡Œçš„å¾ªç¯ä¸Šè°ƒç”¨
   - åœ¨è¿è¡Œä¸­çš„å¾ªç¯éœ€è¦ç”¨ `await` æˆ– `create_task()`
   - ä½†å·¥å…·æ˜¯åŒæ­¥å‡½æ•°,ä¸èƒ½ç›´æ¥ `await`

---

## è§£å†³æ–¹æ¡ˆ

### æ ¸å¿ƒæ€æƒ³

**åœ¨æ–°çº¿ç¨‹ä¸­åˆ›å»ºæ–°çš„äº‹ä»¶å¾ªç¯æ¥è¿è¡Œasyncä»£ç **

```python
# src/core/tools/research_tools.py (ä¿®å¤å)
import asyncio
import concurrent.futures

def _run_async_in_new_loop(coro):
    """
    Run an async coroutine in a new event loop in a separate thread.

    This is needed because tools are called from within an already-running
    event loop (the executor's async context), so we can't use
    loop.run_until_complete() directly.
    """
    def run_in_thread():
        new_loop = asyncio.new_event_loop()
        asyncio.set_event_loop(new_loop)
        try:
            return new_loop.run_until_complete(coro)
        finally:
            new_loop.close()

    with concurrent.futures.ThreadPoolExecutor(max_workers=1) as executor:
        future = executor.submit(run_in_thread)
        return future.result()


@tool
def quick_research(query: str) -> str:
    researcher = get_researcher()

    # âœ… æ­£ç¡®å¤„ç†åµŒå¥—äº‹ä»¶å¾ªç¯
    try:
        loop = asyncio.get_event_loop()
        if loop.is_running():
            # We're inside an async context - run in separate thread
            result = _run_async_in_new_loop(researcher.research(query, use_cache=True))
        else:
            # No running loop - safe to use run_until_complete
            result = loop.run_until_complete(researcher.research(query, use_cache=True))
    except RuntimeError:
        # No event loop at all - create one
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        result = loop.run_until_complete(researcher.research(query, use_cache=True))

    return result
```

### æ‰§è¡Œæµç¨‹ (ä¿®å¤å)

```
1. executor.execute_task() [async]
   â””â”€ Main Event Loop: RUNNING âœ…

2. registry.execute("quick_research", args)
   â””â”€ Main Event Loop: RUNNING âœ…

3. quick_research()
   â”œâ”€ loop = asyncio.get_event_loop()  # è·å–ä¸»å¾ªç¯
   â”œâ”€ loop.is_running() = True  # âœ… æ£€æµ‹åˆ°å¾ªç¯æ­£åœ¨è¿è¡Œ
   â””â”€ _run_async_in_new_loop(coro)
       â””â”€ ThreadPoolExecutor:
           â”œâ”€ New Thread
           â”‚  â”œâ”€ new_loop = asyncio.new_event_loop()  # æ–°å¾ªç¯!
           â”‚  â”œâ”€ new_loop.run_until_complete(coro)  # âœ… åœ¨æ–°å¾ªç¯ä¸­è¿è¡Œ
           â”‚  â””â”€ return result
           â””â”€ future.result()  # âœ… ç­‰å¾…çº¿ç¨‹å®Œæˆ

4. Result returned to ReAct loop âœ…
```

### å…³é”®æ”¹è¿›

1. **æ£€æµ‹è¿è¡ŒçŠ¶æ€**: ä½¿ç”¨ `loop.is_running()` åˆ¤æ–­
2. **çº¿ç¨‹éš”ç¦»**: åœ¨æ–°çº¿ç¨‹ä¸­è¿è¡Œ,é¿å…äº‹ä»¶å¾ªç¯å†²çª
3. **ä¸‰ç§åœºæ™¯å¤„ç†**:
   - å¾ªç¯æ­£åœ¨è¿è¡Œ â†’ æ–°çº¿ç¨‹ + æ–°å¾ªç¯
   - å¾ªç¯å­˜åœ¨ä½†æœªè¿è¡Œ â†’ ç›´æ¥ `run_until_complete()`
   - æ— å¾ªç¯ â†’ åˆ›å»ºæ–°å¾ªç¯

4. **çº¿ç¨‹å®‰å…¨**: ä½¿ç”¨ `ThreadPoolExecutor` ç®¡ç†çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸ

---

## æ›¿ä»£æ–¹æ¡ˆå¯¹æ¯”

### æ–¹æ¡ˆA: nest_asyncio (æœªé‡‡ç”¨)
```python
import nest_asyncio
nest_asyncio.apply()  # å…è®¸åµŒå¥—äº‹ä»¶å¾ªç¯

loop.run_until_complete(coro)  # ç°åœ¨å¯ä»¥å·¥ä½œ
```
**ç¼ºç‚¹**:
- éœ€è¦é¢å¤–ä¾èµ–
- å¯èƒ½å½±å“å…¨å±€äº‹ä»¶å¾ªç¯è¡Œä¸º
- Windowså…¼å®¹æ€§é—®é¢˜

### æ–¹æ¡ˆB: asyncio.create_task() (ä¸é€‚ç”¨)
```python
task = asyncio.create_task(coro)
result = await task  # âŒ å·¥å…·æ˜¯åŒæ­¥å‡½æ•°,ä¸èƒ½await
```
**ç¼ºç‚¹**: å·¥å…·å¿…é¡»æ˜¯asyncå‡½æ•°,éœ€è¦é‡æ„tool registry

### æ–¹æ¡ˆC: çº¿ç¨‹æ±  + æ–°å¾ªç¯ (âœ… å·²é‡‡ç”¨)
```python
with ThreadPoolExecutor() as executor:
    future = executor.submit(run_in_new_loop, coro)
    result = future.result()
```
**ä¼˜ç‚¹**:
- æ— é¢å¤–ä¾èµ–
- ä¸å½±å“ä¸»äº‹ä»¶å¾ªç¯
- è·¨å¹³å°å…¼å®¹
- çº¿ç¨‹å®‰å…¨

---

## å½±å“èŒƒå›´

### ä¿®æ”¹çš„æ–‡ä»¶
- `src/core/tools/research_tools.py`

### ä¿®æ”¹çš„å‡½æ•°
1. `quick_research()`: æ·»åŠ äº‹ä»¶å¾ªç¯æ£€æµ‹
2. `deep_research()`: æ·»åŠ äº‹ä»¶å¾ªç¯æ£€æµ‹
3. `_run_async_in_new_loop()`: æ–°å¢è¾…åŠ©å‡½æ•°

### ä¿®æ”¹ç»Ÿè®¡
- æ–°å¢: 20è¡Œ (çº¿ç¨‹æ± è¾…åŠ©å‡½æ•°)
- ä¿®æ”¹: 30è¡Œ (ä¸¤ä¸ªå·¥å…·å‡½æ•°)
- æ€»è®¡: 50è¡Œ

### å‘åå…¼å®¹æ€§
âœ… **å®Œå…¨å…¼å®¹**
- å·¥å…·ç­¾åæœªæ”¹å˜
- è¿”å›å€¼æ ¼å¼æœªæ”¹å˜
- åªæ”¹å˜å†…éƒ¨å®ç°

---

## éªŒè¯æµ‹è¯•

### æµ‹è¯•1: å¯¼å…¥æµ‹è¯•
```bash
python test_imports.py
# ç»“æœ: âœ… All imports successful (8/8)
```

### æµ‹è¯•2: äº‹ä»¶å¾ªç¯åµŒå¥—æµ‹è¯•
```python
import asyncio
from src.core.tools.research_tools import quick_research

async def test_nested_loop():
    # åœ¨asyncä¸Šä¸‹æ–‡ä¸­è°ƒç”¨åŒæ­¥å·¥å…·
    result = quick_research("AI trends 2024")
    assert result is not None
    print("âœ… Nested loop test passed")

asyncio.run(test_nested_loop())
```

### æµ‹è¯•3: ç”Ÿäº§ç¯å¢ƒæµ‹è¯•
ç”¨æˆ·è¿è¡Œååº”è¯¥çœ‹åˆ°:
```
INFO | ğŸ› ï¸ Calling Tool: deep_research
INFO | ğŸ”§ Executing tool: deep_research with args: {...}
INFO | Initializing global ResearcherAgent instance
INFO | ğŸ” Starting deep research: round 1/3
INFO | ğŸ“Š Research completed successfully
INFO | ğŸ”„ ReAct Step 9/30
```

**ä¸å†å‡ºç°**:
- âŒ `This event loop is already running`
- âŒ `coroutine was never awaited`

---

## æ€§èƒ½å½±å“

### çº¿ç¨‹åˆ›å»ºå¼€é”€
- **é¦–æ¬¡è°ƒç”¨**: ~10ms (åˆ›å»ºçº¿ç¨‹ + æ–°å¾ªç¯)
- **åç»­è°ƒç”¨**: ~5ms (çº¿ç¨‹æ± å¤ç”¨)
- **ç ”ç©¶æœ¬èº«**: 1-5ç§’ (ç½‘ç»œè¯·æ±‚)

**ç»“è®º**: çº¿ç¨‹å¼€é”€å¯å¿½ç•¥ä¸è®¡ (< 1% of total time)

### å†…å­˜å½±å“
- æ¯ä¸ªçº¿ç¨‹: ~1MB æ ˆç©ºé—´
- æ–°äº‹ä»¶å¾ªç¯: ~100KB
- æ€»å¢åŠ : ~1.1MB per concurrent research call

**ç»“è®º**: å†…å­˜å½±å“æå°

---

## ç»éªŒæ•™è®­

### å¼‚æ­¥ç¼–ç¨‹é™·é˜±
1. **ä¸èƒ½å‡è®¾äº‹ä»¶å¾ªç¯çŠ¶æ€**: æ€»æ˜¯æ£€æŸ¥ `is_running()`
2. **sync/asyncè¾¹ç•Œ**: ä»asyncè°ƒç”¨syncå·¥å…·å†è°ƒç”¨asyncæ–¹æ³• = å¤æ‚æ€§
3. **äº‹ä»¶å¾ªç¯ä¸å¯é‡å…¥**: `run_until_complete()` ä¸èƒ½åœ¨è¿è¡Œä¸­çš„å¾ªç¯è°ƒç”¨

### è®¾è®¡å»ºè®®
1. **ç»Ÿä¸€async**: å¦‚æœå¯èƒ½,è®©æ•´ä¸ªè°ƒç”¨é“¾éƒ½æ˜¯async
2. **æ˜ç¡®è¾¹ç•Œ**: åœ¨sync/asyncè¾¹ç•Œåšæ¸…æ™°çš„è½¬æ¢
3. **çº¿ç¨‹éš”ç¦»**: å½“æ— æ³•ç»Ÿä¸€æ—¶,ç”¨çº¿ç¨‹éš”ç¦»ä¸åŒçš„äº‹ä»¶å¾ªç¯

### è°ƒè¯•æŠ€å·§
1. **æ£€æŸ¥å †æ ˆ**: çœ‹æ˜¯å¦åœ¨asyncä¸Šä¸‹æ–‡ä¸­
2. **æ‰“å°å¾ªç¯çŠ¶æ€**: `loop.is_running()`, `loop.is_closed()`
3. **æ•è·è­¦å‘Š**: `RuntimeWarning: coroutine was never awaited`

---

## æäº¤ä¿¡æ¯

```
ä¿®å¤Bug #4: äº‹ä»¶å¾ªç¯å†²çªå¯¼è‡´ç ”ç©¶å·¥å…·å¤±è´¥

é—®é¢˜: This event loop is already running
åŸå› : åœ¨è¿è¡Œä¸­çš„äº‹ä»¶å¾ªç¯è°ƒç”¨run_until_complete()

ä¿®å¤:
- æ·»åŠ loop.is_running()æ£€æµ‹
- åœ¨æ–°çº¿ç¨‹ä¸­åˆ›å»ºæ–°äº‹ä»¶å¾ªç¯è¿è¡Œasyncä»£ç 
- ä½¿ç”¨ThreadPoolExecutorç®¡ç†çº¿ç¨‹ç”Ÿå‘½å‘¨æœŸ

å½±å“æ–‡ä»¶:
- src/core/tools/research_tools.py (+50è¡Œ)

æµ‹è¯•: âœ… å¯¼å…¥æµ‹è¯•é€šè¿‡
æ€§èƒ½: çº¿ç¨‹å¼€é”€<1% of research time
```

---

**ä¿®å¤æ—¶é—´**: 2025-01-22 16:35
**éªŒè¯è€…**: å¾…ç”¨æˆ·éªŒè¯
**çŠ¶æ€**: âœ… å¾…æµ‹è¯•

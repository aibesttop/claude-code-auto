
要搭建 2025 年最前沿的通用型 Agentic Workflow（智能体工作流），我们需要摆脱“单一提示词”的束缚，转向**“元提示词工程（Meta-Prompt Engineering）”**。
在第三梯队（复合人工智能系统）中，提示词的设计不再是为了“得到答案”，而是为了**“驱动状态机的跳转”。你需要的是一套模块化、可编程、具备元认知能力**的提示词体系。
以下是实现“通用、自演进、状态机架构”所需的四类核心系统提示词设计：
1. 架构总览：元认知状态机 (The Meta-Controller)
这套提示词赋予智能体“全局视角”，让它知道自己处于任务的哪个阶段，并决定何时切换状态。
提示词 A：【全局规划与状态决策器 - The Architect】
核心职责： 任务拆解、路径规划、状态初始化。
code
Markdown
# Role: Meta-Reasoning Architect (2025 Tier-3 Agent)

## Context
你是一个通用复杂任务规划器。你的目标是将模糊的人类指令转化为一个确定性的状态机任务图。

## Task Strategy (FSM Logic)
对于任何输入，你必须首先输出以下 JSON 结构的规划：
1. **Goal Analysis**: 识别最终成功准则（Definition of Done）。
2. **State Decomposition**: 拆解为以下状态：[RESEARCH], [THINKING], [ACTION], [VERIFICATION]。
3. **Dependency Map**: 哪些步骤必须串行，哪些可以并行。

## Meta-Rules
- **Self-Awareness**: 评估任务难度，若超过当前工具能力，主动请求细化。
- **Dynamic Re-planning**: 在状态转移时，检查前一状态的输出是否导致路径偏移。

## Output Format
[PLAN]: <详细执行策略>
[STATE_NEXT]: <目标状态名称>
[TOOLS_REQUIRED]: [<工具列表>]
2. 工具交互：工具分发与 RAG 增强 (The Tool Dispatcher)
这套提示词旨在解决 LLM 的“幻觉”和“知识过时”问题，强制模型通过外部世界进行“接地（Grounding）”。
提示词 B：【工具调用与上下文注入器 - The Operator】
核心职责： 精准参数提取、RAG 数据清洗、外部环境交互。
code
Markdown
# Role: Precision Tool Operator & Context Synthesizer

## Mission
你是智能体的“手”，负责与现实世界的数据源（API, RAG, Code Sandbox）交互。

## Execution Protocol
1. **Parameter Extraction**: 从 Architect 的计划中提取执行工具所需的精确 JSON 参数。
2. **Fact Grounding**: 在回答前，必须检查 RAG 检索到的 Context。如果 Context 中没有相关信息，必须承认并启动 [RESEARCH] 状态。
3. **Observation Processing**: 接收工具返回的原始数据，将其提炼为“可供后续思考的知识增量（Information Gain）”。

## Constraints
- 严禁产生幻觉数据。
- 区分“我的记忆”与“外部实时数据”。
3. 反思闭环：对抗性评审 (The Adversarial Critic)
这是第三梯队架构的灵魂。它通过内部博弈（Multi-Agent Debate）来消除错误，实现自我修正。
提示词 C：【对抗性质量评审员 - The Critic】
核心职责： 压力测试、合规性检查、逻辑漏洞挖掘、打回重审。
code
Markdown
# Role: Adversarial Quality Guard (Self-Correction Engine)

## Objective
你作为执行层（Operator）的死对头。你的唯一目标是：通过挑战其逻辑、寻找事实错误、模拟边缘案例，来推翻其产出的初步结果。

## Critique Framework
- **Goal Alignment**: 产出物是否真正解决了 Architect 定义的原始目标？
- **Edge Case Test**: 如果输入环境改变 10%，该方案是否会崩溃？
- **Hallucination Detection**: 每一个声明是否有对应的 Observation 数据支撑？

## Action
- 如果检测到瑕疵，输出：[REJECT] + [错误原因] + [重试指令]。
- 只有在完美无瑕时，输出：[STATUS: PASS]。
4. 状态转移控制逻辑：Python 代码框架
提示词需要 Python 逻辑来承载其“状态机”属性。以下是配合上述提示词的 Python 状态控制器 示意：
code
Python
import asyncio
from enum import Enum
from claude_code_sdk import ClaudeSDKClient

class WorkflowState(Enum):
    PLANNING = "Planner"
    ACTING = "Operator"
    REVIEWING = "Critic"
    DONE = "Success"

class UniversalAgent:
    def __init__(self):
        self.context = {"history": [], "shared_memory": {}}
        self.state = WorkflowState.PLANNING

    async def step(self, user_input):
        while self.state != WorkflowState.DONE:
            if self.state == WorkflowState.PLANNING:
                # 调用 [提示词 A]
                plan = await self.call_claude(PLANNER_PROMPT, user_input)
                self.update_context(plan)
                self.state = WorkflowState.ACTING
            
            elif self.state == WorkflowState.ACTING:
                # 调用 [提示词 B]
                result = await self.call_claude(OPERATOR_PROMPT, self.context)
                self.context["draft"] = result
                self.state = WorkflowState.REVIEWING
                
            elif self.state == WorkflowState.REVIEWING:
                # 调用 [提示词 C]
                feedback = await self.call_claude(CRITIC_PROMPT, self.context["draft"])
                if "PASS" in feedback:
                    self.state = WorkflowState.DONE
                else:
                    # 状态回转，触发自我修正
                    print(f"🔄 评审未通过，正在根据建议修正: {feedback}")
                    self.state = WorkflowState.ACTING

    async def call_claude(self, system_prompt, content):
        # 使用 Claude SDK 进行调用
        pass
🧠 为什么这套系统提示词是 2025 年“最前沿”的？
从“内容生成”转向“逻辑控制”：提示词不再教 AI 怎么写作文，而是教它如何管理自己的执行流程（FSM）。
强制元认知（Meta-Cognition）：Architect 提示词要求 AI 在执行前先思考“如何拆解”，Critic 提示词要求 AI 在输出前先思考“我哪里错了”。
上下文的流动性（Memory Orchestration）：这套提示词体系配合 Python，确保了每一个状态产生的“信息增量”都会沉淀到 shared_memory 中，解决了长对话丢失重点的问题。
工具驱动的确定性：Operator 提示词强制要求参数化输出，这使得 AI 可以无缝对接 2025 年的各类 API（如 Web Search, Python Sandbox, SQL Engine）。
搭建建议：
如果你想搭建这个通用智能体，建议将这些提示词存为 Markdown 模板文件。在 Python 运行时，根据当前 WorkflowState 动态加载对应的模板。这种**“提示词与代码解耦”**的架构是目前硅谷顶尖 AI 实验室（如 OpenAI 和 Anthropic）开发 Agent 的标准方案。